<!doctype html>
<!-- Auteur : David Roche @davR74130 -->
<html lang="fr">
	<head>
		<meta charset="utf-8">
		<title>Structures de données : les listes, les piles et les files</title>
		<link rel="stylesheet" href="css/css/vendor/bootstrap.min.css">
		<link rel="stylesheet" href="css/css/flat-ui.min.css">
		<link rel="stylesheet" href="highlight/styles/tomorrow-night.css">
		<link rel="stylesheet" href="css/style.css">
		<script src="highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
    <script src="./css/js/vendor/jquery.min.js"></script>
    <script src="./css/js/flat-ui.min.js"></script>
		<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-53303169-1"></script>
	<script>
  		window.dataLayer = window.dataLayer || [];
  		function gtag(){dataLayer.push(arguments);}
  		gtag('js', new Date());

  		gtag('config', 'UA-53303169-1');
	</script>
	</head>
	<body>
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">NSI terminale</span>
					<span class="navbar-brand">Structures de données : les listes, les piles et les files</span>
        </div>
      </div>
    </nav>
    <div class="container act">
		<p>
			De nombreux algorithmes "classiques" manipulent des structures de données plus complexes que des simples nombres (nous aurons l'occasion d'en voir plusieurs cette année).
			Nous allons ici voir quelques-unes de ces structures de données. Nous allons commencer par des types de structures relativement simples : les listes, les piles et les files.
			Ces trois types de structures sont qualifiés de linéaires.
		</p>
		<h3>Les listes</h3>
		<p>
			Une liste est une structure de données permettant de regrouper des données de manière à pouvoir y accéder librement. L'ordre des éléments dans une liste est fondamental.
			En effet, chaque élément d'une liste est repéré par un indice de position. Le premier élément d'une liste a pour indice de position 1, le deuxième élément l'indice de position 2...
			Une liste peut être vide. Voici les opérations qui peuvent être effectuées sur une liste :
		</p>
		<ul>
			<li>
				accéder à l'élément d'indice de position k (acc)
			</li>
			<li>
				supprimer l'élément d'indice de position k (suppr)
			</li>
			<li>
				insérer un élément l'indice de position k (insert)
			</li>
		</ul>
		<p>
			Il est aussi possible de savoir si une liste est vide (liste_vide?) ou bien encore de connaitre le nombre d'éléments présents dans une liste (longueur).
		</p>
		<p>
			Exemples :
		</p>
		<p>
			Soit une liste L composée des éléments suivants (attention l'ordre est important) : 12, 14, 8, 7, 19 et 22. Pour chaque exemple ci-dessous on repart de la liste d'origine :
		</p>
		<ul>
			<li>
				acc(L,3) renvoie 8
			</li>
			<li>
				suppr(L,2) la liste L est désormais composée des éléments suivants : 12, 8, 7, 19 et 22
			</li>
			<li>
				insert(L,3,42) la liste L est désormais composée des éléments suivants : 12, 14, 42, 8, 7, 19 et 22
			</li>
			<li>
				liste_vide?(L) renvoie faux
			</li>
			<li>
				longueur(L) renvoie 6
			</li>
		</ul>
		<h4>À faire vous-même 1</h4>
		<p>
			Soit une liste L composée des éléments suivants : 12, 14, 8, 7, 19 et 22. Quel est l'effet de l'instruction suppr(L,4) ?
		</p>
		<hr />
		<p>
			L'écriture des fonctions vues ci-dessus n'est pas standard :
			il n'existe aucun consensus sur l'utilisation de ces fonctions dans l'écriture d'algorithme en langage naturel. Le nom d'une fonction et les paramètres qu'elle accepte changent souvent d'un ouvrage à un autre.
			Dans certains ouvrages on trouvera par exemple un L.long() à la place d'un longeur(L). L'essentiel est d'être bien clair dès le départ et de se faire comprendre.
		</p>
		<h3>Les piles</h3>
		<p>
			On retrouve dans les piles une partie des propriétés vues sur les listes. Dans les piles, au contraire des listes, il n'est pas possible de travailler sur n'importe quel élément :
			il est uniquement possible de manipuler le dernier élément introduit dans la pile. On prend souvent l'analogie avec une pile d'assiettes : dans une pile d'assiettes la seule assiette
			directement accessible et la dernière assiette qui a été déposée sur la pile.
		</p>
		<div class="centrer">
			<img src="img/nsi_term_structDo_liste_1.png" alt="Pile"/>
		</div>
		<p>
			Les piles sont basées sur le principe LIFO (Last In First Out : le dernier rentré sera le premier à sortir). On retrouve souvent ce principe LIFO en informatique.
		</p>
		<p>
			Voici les opérations que l'on peut réaliser sur une pile :
		</p>
		<ul>
			<li>
				on peut savoir si une pile est vide (pile_vide?)
			</li>
			<li>
				on peut empiler un nouvel élément sur la pile (push)
			</li>
			<li>
				on peut récupérer l'élément au sommet de la pile tout en le supprimant. On dit que l'on dépile (pop)
			</li>
			<li>
				on peut accéder à l'élément situé au sommet de la pile sans le supprimer de la pile (sommet)
			</li>
			<li>
				on peut connaitre le nombre d'éléments présents dans la pile (taille)
			</li>
		</ul>
		<p>
			Exemples :
		</p>
		<p>
			Soit une pile P composée des éléments suivants  : 12, 14, 8, 7, 19 et 22 (le sommet de la pile est 22)  Pour chaque exemple ci-dessous on repart de la pile d'origine :
		</p>
		<ul>
			<li>
				pop(P) renvoie 22 et la pile P est maintenant composée des éléments suivants  : 12, 14, 8, 7 et 19 (le sommet de la pile est 19)
			</li>
			<li>
				push(P,42) la pile P est maintenant composée des éléments suivants : 12, 14, 8, 7, 19, 22 et 42
			</li>
			<li>
				sommet(P) renvoie 22, la pile P n'est pas modifiée
			</li>
			<li>
				si on applique pop(P) 6 fois de suite, pile_vide?(P) renvoie vrai
			</li>
			<li>
				Après avoir appliqué pop(P) une fois, taille(P) renvoie 5
			</li>
		</ul>
		<h4>À faire vous-même 2</h4>
		<p>
			Soit une pile P composée des éléments suivants  : 15, 11, 32, 45 et 67 (le sommet de la pile est 67). Quel est l'effet de l'instruction pop(P)
		</p>
		<hr />
		<h3>Les files</h3>
		<p>
			Comme les piles, les files ont des points communs avec les listes. Différences majeures : dans une file on ajoute des éléments à une extrémité de la file et on supprime des éléments à l'autre extrémité.
			On prend souvent l'analogie de la file d'attente devant un magasin pour décrire une file de données.
		</p>
		<div class="centrer">
			<img src="img/nsi_term_structDo_liste_2.png" alt="File"/>
		</div>
		<p>
			Les files sont basées sur le principe FIFO (First In First Out : le premier qui est rentré sera le premier à sortir. Ici aussi, on retrouve souvent ce principe FIFO en informatique.
		</p>
		<p>
			Voici les opérations que l'on peut réaliser sur une file :
		</p>
		<ul>
			<li>
				on peut savoir si une file est vide (file_vide?)
			</li>
			<li>
				on peut ajouter un nouvel élément à la file (ajout)
			</li>
			<li>
				on peut récupérer l'élément situé en bout de file tout en le supprimant (retire)
			</li>
			<li>
				on peut accéder à l'élément situé en bout de file sans le supprimer de la file (premier)
			</li>
			<li>
				on peut connaitre le nombre d'éléments présents dans la file (taille)
			</li>
		</ul>
		<p>
			Exemples :
		</p>
		<p>
			Soit une file F composée des éléments suivants  : 12, 14, 8, 7, 19 et 22 (le premier élément rentré dans la file est 22 ; le dernier élément rentré dans la file est 12).  Pour chaque exemple ci-dessous on repart de la file d'origine :
		</p>
		<ul>
			<li>
				ajout(F,42) la file F est maintenant composée des éléments suivants  : 42, 12, 14, 8, 7, 19 et 22 (le premier élément rentré dans la file est 22 ; le dernier élément rentré dans la file est 42)
			</li>
			<li>
				retire(F) la file F est maintenant composée des éléments suivants : 12, 14, 8, 7, et 19 (le premier élément rentré dans la file est 19 ; le dernier élément rentré dans la file est 12)
			</li>
			<li>
				premier(F) renvoie 22, la file F n'est pas modifiée
			</li>
			<li>
				si on applique retire(F) 6 fois de suite, pile_vide?(F) renvoie vrai
			</li>
			<li>
				Après avoir appliqué retire(F) une fois, taille(F) renvoie 5
			</li>
		</ul>
		<h4>À faire vous-même 3</h4>
		<p>
			Soit une file F composée des éléments suivants  : 1, 12, 24, 17, 21 et 72 (le premier élément rentré dans la file est 72 ; le dernier élément rentré dans la file est 1). Quel est l'effet de l'instruction ajout(F,25)
		</p>
		<hr />
		<h3>Types abstraits et représentation concrète des données</h3>
		<p>
			Nous avons évoqué ci-dessus la manipulation des types de données (liste, pile et file) par des algorithmes, mais, au-delà de la beauté intellectuelle de réfléchir sur ces algorithmes,
			le but de l'opération est souvent, à un moment ou un autre, de "traduire" ces algorithmes dans un langage compréhensible pour un ordinateur (Python, Java, C,...).
			On dit alors que l'on implémente un algorithme. Il est donc aussi nécessaire d'implémenter les types de données comme les listes, les piles ou les files afin qu'ils soient utilisables par les ordinateurs.
			Les listes, les piles ou les files sont des "vues de l'esprit" présent uniquement dans la tête des informaticiens, on dit que ce sont des types abstraits de données (ou plus simplement des types abstraits). L'implémentation de ces types abstrait, afin qu'ils soient utilisables par une machine, est loin
			d'être une chose triviale. L'implémentation d'un type de données dépend du langage de programmation. Il faut, quel que soit le langage utilisé, que le programmeur retrouve
			les fonctions qui ont été définies pour le type abstrait (pour les listes, les piles et les files cela correspond aux fonctions définies ci-dessus). Certains types abstraits ne sont pas forcément implémentés dans un langage donné, si le programmeur veut utiliser ce type abstrait, il faudra qui le programme par lui-même en utilisant
			les "outils" fournis par son langage de programmation.
		</p>
		<p>
			Pour implémenter les listes (ou les piles et les files), la plupart des langages de programmation utilisent 2 structures : les tableaux et les listes chaînées.
		</p>
		<p>
			Un tableau est une suite contiguë de cases mémoires (les adresses des cases mémoire se suivent) :
		</p>
		<div class="centrer">
			<img src="img/nsi_term_structDo_liste_3.png" alt="File"/>
		</div>
		<p>
			Le système réserve une plage d'adresse mémoire afin de stocker des éléments.
		</p>
		<div class="centrer">
			<img src="img/nsi_term_structDo_liste_4.png" alt="File"/>
		</div>
		<p>
			La taille d'un tableau est fixe : une fois que l'on a défini le nombre d'éléments que le tableau peut accueillir, il n'est pas possible modifier sa taille. Si l'on veut insérer une donnée, on doit créer un nouveau tableau plus grand et déplacer les éléments du premier tableau vers le second tout en ajoutant la donnée au bon endroit !
		</p>
		<p>
			Dans certains langages de programmation, on trouve une version "évoluée" des tableaux : les tableaux dynamiques. Les tableaux dynamiques ont une taille qui peut varier. Il est donc relativement simple d'insérer des éléments dans le tableau. Ce type de tableaux permet d'implémenter facilement le type abstrait liste (de même pour les piles et les files)
		</p>
		<p>
			À noter que les "listes Python" (<a href="https://docs.python.org/fr/3/tutorial/datastructures.html" target="_blank">listes Python</a>) sont des tableaux dynamiques.
		</p>
		<div class="centrer">
			<img src="img/nsi_term_structDo_liste_5.png" alt="File"/>
			<figcaption>tableau dynamique</figcaption>
		</div>
		<h4>À faire vous-même 4</h4>
		<p>
			Étudiez l'implémentation des piles et des files en Python en vous aidant de la <a href="https://docs.python.org/fr/3/tutorial/datastructures.html" target="_blank">documentation officielle</a>.
		</p>
		<hr />
		<p>
			Autre type de structure que l'on rencontre souvent et qui permet d'implémenter les listes, les piles et les files : les listes chaînées.
		</p>
			<p>
				Dans une liste chaînée, à chaque élément de la liste on associe 2 cases mémoire : la première case contient l'élément et la deuxième contient l'adresse mémoire de l'élément suivant.
			</p>
		<div class="centrer">
			<img src="img/nsi_term_structDo_liste_6.png" alt="File"/>
		</div>
		<p>
			Il est relativement facile d'insérer un élément dans une liste chaînée :
		</p>
		<div class="centrer">
			<img src="img/nsi_term_structDo_liste_7.png" alt="File"/>
		</div>
		</div>
</html>
